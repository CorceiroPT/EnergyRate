{"name":"ENTSO-e Energy Rate","type":"com.fibaro.multilevelSensor","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_727"},"sections":{"items":[{"components":[{"name":"labelInfo","style":{"weight":"1.2"},"text":"labelInfo","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"refreshButton","style":{"weight":"1.2"},"text":"Refresh","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_727"}}},"uiCallbacks":[{"callback":"refresh_action","eventType":"onReleased","name":"refreshButton"}],"quickAppVariables":[{"name":"ENTSOE_Token","type":"string","value":"f442d0b3-450b-46d7-b752-d8d692fdb2c8"},{"name":"TariffHistory","type":"string","value":"365"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":false,"content":"--[[\n    ENTSO-e Energy Rate is an FIBARO QuickApp that get current Spot prices for almost every european countries and is independent from any energy power company for free.\n\n    How to get your own Token:\n    I´ve provide an Token that works \"out of the box\", but can be changed in the future, so if you like you can create your own free token at ENTSO-e, but not required.\n    Register an ENTSO-e account at: https://transparency.entsoe.eu/\n    How to get an Token: https://transparency.entsoe.eu/content/static_content/download?path=/Static%20content/API-Token-Management.pdf\n\n    The Exchange rate service (https://exchangerate.host) that is used in this QuickApp to get your local currency is also free to use and if you like it, donate a cappuccino at https://exchangerate.host/#/donate ;)\n\n    This is the first time I have developed in Lua language, so have some indulgence, but hey it works and I hope it works for U 2 ;)\n    I would appreciate if you have any feedback or suggestions to make this QuickApp more usefull, please send me an email at energyrate@jamdata.com and I´ll try to do my best :)\n\n    Changelog:\n    v1.0 First release 2023-01\n    v1.1 New feature release 2023-03\n        - Keeps Tariff rate history in FIBARO.\n        - Show more usefull info in QA panel.\n        - Add new global month avrage level variable \"EnergyMonthLevel\" for those that pay energy consumtion per month avrage.\n        - Add new QA variable \"TariffHistory\" for how many days to store history in FIBARO tariff rates.\n        - Localized panel text for language: EN, DK, NO, SV (if you want to help me with translation, please send me an email at energyrate@jamdata.com)\n\n        Braking changes that you need to change in your scenes if your using first release v1.0:\n            Global variable name change from \"EnergyRateArea\" to \"EnergyArea\".\n            Global variable name change from \"EnergyRateMedium\" to \"EnergyMediumPrice\".\n            Global variable name change from \"EnergyRateLevel\" to \"EnergyHourLevel\".\n            Global variable name change from \"EnergyRateNextLevel\" to \"EnergyNextHourLevel\".\n\n    v1.2 Customer wishes release 2023-04\n        - Option to add tax to the energy price.\n        - Show if service error message.\n\n]]\n\nfunction QuickApp:onInit()\n    self.debugOn = false -- Write to debug console true/false\n    self.httpClient = net.HTTPClient()\n    \n    -- Variables for exchangerate.host Api service\n    -- https://exchangerate.host\n    self.exchangerate_baseURL = \"https://api.exchangerate.host/\"\n    self.exchangeRate = 1 -- Set default excahnge rate to 1:1\n\n    -- Variables for ENTSO-e Transparency Platform Api service\n    -- https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html\n    self.entsoe_baseURL = \"https://web-api.tp.entsoe.eu/api\"\n    self.default_entsoe_token = \"f442d0b3-450b-46d7-b752-d8d692fdb2c8\" -- See \"How to get your own Token:\" above.\n    self.default_area_name = \"Sweden (SE3)\"\n    self.default_medium_price = \"0.2\"  -- 0,2 EUR/kWh\n    self.default_tax_percentage = \"0\"  -- 0% tax\n    self.default_tariff_history = \"62\" -- Default ~2 month\n    self.nextday_releaseTime = 12 -- The UTC time of the day ENTSO-e releses the next day prices\n    self.child_rank_name = \"ENTSO-e Next Energy Rate\"\n    self.next_rank_device_id = nil\n    self.variable_token_name = \"ENTSOE_Token\"\n    self.variable_tariff_history_name = \"TariffHistory\"\n    self.global_var_area_name = \"EnergyArea\"    \n    self.global_var_medium_price_name = \"EnergyMediumPrice\"\n    self.global_var_level_name = \"EnergyHourLevel\"\n    self.global_var_next_level_name = \"EnergyNextHourLevel\"\n    self.global_var_month_level_name = \"EnergyMonthLevel\"\n    self.global_var_tax_percentage_name = \"EnergyTaxPercentage\"\n\n    self.serviceRequestTime = \"--\"  -- Last datetime when we request ENTSO-e webservice.\n    self.serviceSuccess = true\n    self.serviceMessage = \"\"\n\n    -- Let´s start\n    self:mainStart()\nend\n\nfunction QuickApp:mainStart()\n    self:refreshVariables()\n\n    -- Create global varaiables and set default values (See: defaults)\n    self:createGlobalVariables()\n    self:createAreaVariables()\n    self:setDefaultVariables()\n            \n    -- Init Child device to display next hour rate in Fibaro (See: QAChild_NextRank)\n    self:initChildDevices({[\"com.fibaro.multilevelSensor\"] = ENTSOE_Next_Rank})\n    self:validateChildren()\n    \n    -- Start loop, one for request ENTSO-e service and exchange rate and one for updating global variables and panel display.\n    self:d(\">>>> Start ENTSO-e Energy Rate <<<<\")\n    self:serviceRequestLoop(false) -- Request ExchangeRate and ENTSO-e serices\nend\n\n-- Trigger if panel button pressed\nfunction QuickApp:refresh_action()\n    self:d(\"Execute ENTSO-e service update on button event...\")\n    self:updateView(\"refreshButton\", \"text\", \"⌛ \" ..self.i18n:get(\"Refreshing\") ..\"...\")\n    self:serviceRequestLoop(true)\nend\n\n-- ENTSO-e and Exchange rate service loop\nfunction QuickApp:serviceRequestLoop(forceUpdate)\n    -- Set Update service request loop to every hour\n    local loopTime = (tonumber(os.date(\"%M\"))) * 60 * 1000\n   \n     -- Refresh variable values\n    self:refreshVariables()\n\n    -- Get current Exchange rate from Exchangerate.host Api Service\n    if (self.currency ~= \"EUR\") then\n        self:getServiceExchangeData(QuickApp.setExchangeRate, self)\n    end\n    \n    -- Check if table is already up to date, otherwise request service and update table  \n    if forceUpdate or not self:IsFibaroTariffUpToDate() then               \n        -- Get Energy Rates from ENSO-e Service (wait 2 sec for Exchange rate http request to complete)\n        fibaro.setTimeout(2000, function() self:updateTariffData() end)\n    end\n\n    -- Start this Service request loop\n    fibaro.setTimeout(loopTime, function() self:serviceRequestLoop() end)\n\n    -- Update variables and panel\n    self:displayLoop(true) \nend\n\nfunction QuickApp:updateTariffData()\n    -- Get current day energy rates.\n    -- ENTSO-e service only returns 24 hour Rates on each request even if we define another \"toDate\" :(\n    self:getServiceRateData(QuickApp.updateFibaroTariffTable, self, os.date(\"!%Y%m%d0000\"), os.date(\"!%Y%m%d2300\"))\n\n    -- Get next 24 hour energy rates if they have been released, normally the next day energy rates are released after 12:00 UTC.\n    -- We also need the next day rates to solve the midnight shift between 23:00 and 00:00.\n    if (self.serviceSuccess and tonumber(os.date(\"!%H\", os.time())) >= self.nextday_releaseTime) then\n        fibaro.setTimeout(2000, function() \n                                    self:getServiceRateData(QuickApp.updateFibaroTariffTable, self, os.date(\"!%Y%m%d0000\", os.time() + 86400), os.date(\"!%Y%m%d2300\", os.time() + 86400)) \n                                end)\n    end\n    \n    self.serviceRequestTime = os.date(\"%Y-%m-%d %H:%M\")\nend\n\n-- Variables and panel update display loop\nfunction QuickApp:displayLoop(first)\n    -- Set Update display loop to every full hour + 1 min\n    local loopTime = 10000\n    if not first then loopTime = (61 - tonumber(os.date(\"%M\"))) * 60 * 1000 end\n\n     -- Refresh variable values\n    self:refreshVariables()\n    \n    -- Set Energy rates data to display\n    self:displayEnergyRate()\n\n    -- Start this display loop each hour\n    fibaro.setTimeout(loopTime, function() self:displayLoop(false) end)\nend"},{"name":"QAChild_NextRank","isMain":false,"isOpen":false,"content":"function QuickApp:validateChildren()\r\n    self:d(\"Validate QuickApp Children\")\r\n    for id,device in pairs(self.childDevices) do\r\n        self:d(tostring(id) .. \" = \" .. device.name)\r\n\r\n        if (device.name == self.child_rank_name) then\r\n            self.next_rank_device_id = id\r\n            self:d(tostring(id) .. \" - child_rank_name: \" .. device.name)\r\n        end\r\n    end\r\n\r\n    if self.next_rank_device_id == nil then\r\n        self:d(\"Create QuickApp Children\")\r\n        self:createRankChild()\r\n    end\r\nend\r\n\r\nfunction QuickApp:createRankChild()\r\n    local child = self:createChildDevice({\r\n        name = self.child_rank_name,\r\n        type = \"com.fibaro.multilevelSensor\",\r\n    }, ENTSOE_Next_Rank)\r\n    self.next_rank_device_id = child.id\r\nend\r\n\r\n\r\nclass 'ENTSOE_Next_Rank' (QuickAppChild)\r\nfunction ENTSOE_Next_Rank:__init(device)\r\n    -- You should not insert code before QuickAppChild.__init.\r\n    QuickAppChild.__init(self, device) -- We must call a constructor from the parent class\r\n    self:updateProperty(\"unit\", \"\")\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setValue(value)\r\n    self:updateProperty(\"value\", value)\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setUnit(unit)\r\n    self:updateProperty(\"unit\", unit)\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setLog(log)\r\n    self:updateProperty(\"log\", log)\r\nend\r\n"},{"name":"functions","isMain":false,"isOpen":false,"content":"function QuickApp:d(msg)\r\n    if self.debugOn then self:debug(msg) end\r\nend\r\n\r\nfunction QuickApp:getRateDate(dateString, format, addHour, timezoneOffset)\r\n    if format == nil then format = \"%Y-%m-%d %H:%M\" end\r\n    if addHour == nil then addHour = 0 end\r\n    if timezoneOffset == nil then timezoneOffset = 0 end\r\n\r\n    -- Input dateString = \"2022-12-25 23:00\"\r\n    local iyear, imonth, iday, ihour, iminute = dateString:match(\"(%d+)-(%d+)-(%d+) (%d+):(%d+)\")\r\n    local timestamp = os.time({year = iyear, month = imonth, day = iday, hour = ihour, min = iminute}) + timezoneOffset\r\n    return os.date(format, timestamp + (addHour * 60 * 60))\r\nend\r\n\r\nfunction QuickApp:getRateReleaseTime(timezoneOffset)\r\n    if timezoneOffset == nil then timezoneOffset = 0 end\r\n    return os.date(\"!%H:%M\", os.time({year=2000, month=1, day=1, hour=self.nextday_releaseTime, min=0}) + timezoneOffset)\r\nend\r\n\r\nfunction QuickApp:tableCount(T)\r\n    if T == nil then return 0 end\r\n    local count = 0\r\n    for _ in pairs(T) do count = count + 1 end\r\n    return count\r\nend\r\n\r\nfunction QuickApp:getXmlDate(xmlString, name, format)\r\n    -- Input dateString = \"2022-12-25T23:00Z\"\r\n    local dateString = self:getXmlElement(xmlString, name)\r\n    local iyear, imonth, iday, ihour, iminute = dateString:match(\"(%d+)-(%d+)-(%d+)T(%d+):(%d+)Z\")\r\n    local timestamp = os.time({year = iyear, month = imonth, day = iday, hour = ihour, min = iminute})\r\n    return os.date(format, timestamp)\r\nend\r\n\r\nfunction QuickApp:getXmlElement(data, name)\r\n    return data:match(\"<\"..name..\">(.-)</\"..name..\">\")\r\nend\r\n\r\n-- Extract ENTSO-e prices from response xml into Lua table\r\nfunction QuickApp:xml2PriceTable(xml)\r\n    local priceTable = {}\r\n    local ni, c, label, xarg, empty\r\n    local i, j = 1, 1\r\n\r\n    while true do\r\n        ni, j, c, label, xarg, empty = string.find(xml, \"<(%/?)([%w:_]+)(.-)(%/?)>\", i)\r\n        if not ni then break end\r\n        local text = string.sub(xml, i, ni-1)\r\n   \r\n        if not string.find(text, \"^%s*$\") and label == \"price\" then\r\n            table.insert(priceTable, text)\r\n        end\r\n\r\n        i = j+1\r\n    end\r\n\r\n    return priceTable\r\nend\r\n\r\nfunction QuickApp:getLocalTariffRate(mainRate, exchangeRate, tax)\r\n    if (tax == nil or tax == 0) then tax = 1 end\r\n    if (exchangeRate == nil) then exchangeRate = 1 end\r\n\r\n    -- Recalculate main rate from EUR/mWh to {local currency}/kWh * tax\r\n    local rate = tonumber(string.format(\"%.2f\",((tonumber(mainRate)*tonumber(exchangeRate)/1000)*tax)))\r\n    if rate <= 0 then rate = 0.0001 end -- FIBARO can't accept 0 as tariff rate price :(\r\n    return rate\r\nend\r\n\r\nfunction QuickApp:getRank(value)\r\n    -- Set defaults\r\n    if (value == nil) then return \"\" end\r\n    if (value == \"nan\") then return \"\" end\r\n    if (value == \"--\") then return \"\" end\r\n    if (value == 0) then return \"\" end\r\n    \r\n    local medValue = tonumber(self.mediumPrice)\r\n    if (medValue == nil) then medValue = 1 end\r\n    \r\n    -- Calculate percent from medium energy rate\r\n    local percent = (value * 100 / medValue) - 100\r\n    \r\n    local rank = \"MEDIUM\"\r\n    if (percent > 50) then rank = \"HIGH\" end       --  50% higher than medium rate\r\n    if (percent > 100) then rank = \"VeryHIGH\" end  -- 100% higher than medium rate\r\n    if (percent < -100) then rank = \"VeryLOW\" end  -- 100% lower than medium rate\r\n    if (percent < -50) then rank = \"LOW\" end       --  50% lower than medium rate\r\n\r\n    self:d(\"Set the rank level between percentage of \" .. value .. \" and \" .. medValue .. \" = \" .. rank .. \" (\" .. percent .. \"%)\")\r\n\r\n    return rank\r\nend\r\n\r\nfunction QuickApp:getRankIcon(value)\r\n    if (value == \"VeryHIGH\") then return \"🔴\" end\r\n    if (value == \"HIGH\") then return \"🟠\" end\r\n    if (value == \"MEDIUM\") then return \"🟡\" end\r\n    if (value == \"LOW\") then return \"🔵\" end\r\n    if (value == \"VeryLOW\") then return \"🟢\" end\r\n    return \"⛔\"\r\nend\r\n\r\nfunction QuickApp:getNextDirection(currentValue, nextValue)\r\n    if (currentValue == nil) then currentValue = 0 end\r\n    if (nextValue == nil) then nextValue = 0 end\r\n    if (currentValue > nextValue) then return \"⇩\" end\r\n    if (currentValue < nextValue) then return \"⇧\" end\r\n    return \"⇨\"\r\nend"},{"name":"defaults","isMain":false,"isOpen":false,"content":"function QuickApp:createGlobalVariables()\r\n    -- Create medium rate price global variable\r\n    local medium_var = {\r\n            name=self.global_var_medium_price_name,\r\n            isEnum=false,\r\n            readOnly=false,\r\n            value=\"0.2\", -- 0,2 EUR/kWh\r\n            enumValues=nil\r\n        }\r\n    api.post('/globalVariables/',medium_var)\r\n    \r\n    -- Create tax percentage global variable\r\n    local tax_var = {\r\n            name=self.global_var_tax_percentage_name,\r\n            isEnum=false,\r\n            readOnly=false,\r\n            value=\"0\", -- 0 %\r\n            enumValues=nil\r\n        }\r\n    api.post('/globalVariables/',tax_var)\r\n\r\n    -- Create Level rate global variable\r\n    local level_var = {\r\n            name=self.global_var_level_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=\"HIGH\",\r\n            enumValues={\"VeryLOW\",\"LOW\",\"MEDIUM\",\"HIGH\",\"VeryHIGH\"}\r\n        }\r\n    api.post('/globalVariables/',level_var)\r\n\r\n    -- Create Next Level rate global variable\r\n    level_var.name = self.global_var_next_level_name\r\n    api.post('/globalVariables/',level_var)\r\n\r\n    -- Create Month Level rate global variable\r\n    level_var.name = self.global_var_month_level_name\r\n    api.post('/globalVariables/',level_var)\r\nend\r\n\r\nfunction QuickApp:setDefaultVariables()\r\n    -- Not required, but you can register and create your own account and get a token at ENTSO-e.\r\n    -- Register an free ENTSO-e account at: https://transparency.entsoe.eu/\r\n    -- How to get an Token: https://transparency.entsoe.eu/content/static_content/download?path=/Static%20content/API-Token-Management.pdf \r\n    if self.token == nil or self.token == \"\" then      \r\n        self.token = self.default_entsoe_token\r\n        self:setVariable(self.variable_token_name, self.token)\r\n    end\r\n\r\n    -- Set local variable Days to keep FIBARO Tariff history\r\n    if self.tariffHistory == nil or self.tariffHistory == \"\" then\r\n        self.tariffHistory = self.default_tariff_history\r\n        self:setVariable(self.variable_tariff_history_name, self.tariffHistory)\r\n    end\r\n\r\n    -- Set local variable medium price rate\r\n    if self.mediumPrice == nil or self.mediumPrice == \"\" then\r\n        self.mediumPrice = self.default_medium_price\r\n        self:setGlobalVariable(self.global_var_medium_price_name, self.mediumPrice)\r\n    end\r\n\r\n    -- Set local variable tax\r\n    if self.tax == nil or self.tax == \"\" then\r\n        self.tax = self.default_tax_percentage\r\n        self:setGlobalVariable(self.global_var_tax_percentage_name, self.tax)\r\n    end\r\n\r\n    -- Set global variable Energy ENTSO-e Area name\r\n    if self.areaName == nil or self.areaName == \"\" then\r\n        self.areaName = self.default_area_name\r\n    end\r\n    if self.areaCode == nil or self.areaCode == \"\" then\r\n        fibaro.setGlobalVariable(self.global_var_area_name, self.areaName)\r\n    end\r\n    \r\n    self:refreshVariables()\r\nend\r\n\r\nfunction QuickApp:refreshVariables()\r\n    -- Get FIBARO settings\r\n    local fibaroSettings = api.get(\"/settings/info\")\r\n    self.currency = fibaroSettings.currency\r\n    self.timezoneOffset = tonumber(fibaroSettings.timezoneOffset)\r\n    --self.dateFormat = tonumber(fibaroSettings.dateFormat)\r\n    --self.timeFormat = tonumber(fibaroSettings.timeFormat)\r\n    --self.decimalMark = tonumber(fibaroSettings.decimalMark)\r\n    self.i18n = i18n:new(fibaroSettings.defaultLanguage)\r\n        \r\n    -- Refresh variable values\r\n    self.token = self:getVariable(self.variable_token_name)\r\n    self.tariffHistory = self:getVariable(self.variable_tariff_history_name)\r\n    self.mediumPrice = fibaro.getGlobalVariable(self.global_var_medium_price_name)\r\n    self.tax = (fibaro.getGlobalVariable(self.global_var_tax_percentage_name) / 100) + 1\r\n    self.areaName = fibaro.getGlobalVariable(self.global_var_area_name)\r\n    self.areaCode = self:getAreaCode(self.areaName)\r\n    self:updateProperty(\"unit\", self.currency .. \"/kWh\")\r\nend"},{"name":"display","isMain":false,"isOpen":false,"content":"function QuickApp:displayEnergyRate()   \r\n    -- Get current Fibaro Tariff Data\r\n    local tariffData = self:getFibaroTariffData()\r\n    \r\n    -- Calculate values\r\n    local rank = self:getRank(tariffData.currentRate)\r\n    local nextRank = self:getRank(tariffData.nextRate)\r\n    local nextDir = self:getNextDirection(tariffData.currentRate, tariffData.nextRate)\r\n    local prevDir = self:getNextDirection(tariffData.previousRate, tariffData.currentRate)\r\n    local rateDiff = string.format(\"%.2f\", tonumber(tariffData.nextRate - tariffData.currentRate))\r\n    local prevDiff = string.format(\"%.2f\", tonumber(tariffData.currentRate - tariffData.previousRate))\r\n\r\n    -- Set dafaults\r\n    local avgRate = 0\r\n    local avgRank = \"\"\r\n    local refresh = \"♻️\"\r\n    local lastRqt = refresh ..self.i18n:get(\"LoadingEnergyRates\") ..\"️...\"\r\n    local lastUpd = refresh ..self.i18n:get(\"Refreshing\") ..\"️...\"\r\n    local areaName = self.areaName\r\n\r\n    -- Set Exchange rate\r\n    local exchangeRate = \"--\"\r\n    if (self.exchangeRate > 0) then exchangeRate = self.exchangeRate end\r\n\r\n    -- If Service request failed\r\n    if not self.serviceSuccess then\r\n        lastRqt = \"n/a\"\r\n        lastUpd = \"n/a\"\r\n        areaName = areaName .. \"\\n⚠️ \" ..self.i18n:get(\"MissingEnergyRatesForSelectedArea\") ..\"\\n\" ..self.serviceMessage\r\n    end\r\n\r\n    -- Only update variables and tariff if we got \"real\" rate data\r\n    if tariffData.count > 0 then \r\n        avgTotalRank = self:getRank(tariffData.avgTotalRate)\r\n        avgDayRank = self:getRank(tariffData.avgDayRate)\r\n        avgMonthRank = self:getRank(tariffData.avgMonthRate)\r\n\r\n        refresh = \"\"\r\n\r\n        self:updateProperty('value', tonumber(tariffData.currentRate))\r\n        self:updateProperty('log', self:getRankIcon(rank) ..rank)\r\n        fibaro.setGlobalVariable(self.global_var_level_name, rank)        \r\n        fibaro.setGlobalVariable(self.global_var_next_level_name, nextRank)\r\n        fibaro.setGlobalVariable(self.global_var_month_level_name, avgMonthRank)\r\n        fibaro.call(self.next_rank_device_id, 'setLog', self:getRankIcon(nextRank) ..nextRank)\r\n        fibaro.call(self.next_rank_device_id, 'setUnit', \" \" .. nextDir)\r\n        fibaro.call(self.next_rank_device_id, 'setValue', rateDiff)\r\n\r\n        lastUpd = os.date(\"%Y-%m-%d %H:%M\")\r\n        self:updateView(\"refreshButton\", \"text\", self.i18n:get(\"Refresh\"))\r\n        \r\n        self:d(\"Display panels updated: \" ..os.date(\"%H:%M:%S\"))\r\n    end\r\n\r\n    -- Update FIBARO Info panel\r\n          local labelInfo = self.i18n:get(\"TodayRates\") ..\" (\" ..self.i18n:get(\"Range\") ..\": \" ..tariffData.minDayRate ..\" \" ..self.i18n:get(\"To\") ..\" \" ..tariffData.maxDayRate ..\" \" ..self.currency ..\")\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(rank) ..\" \" ..self.i18n:get(\"CurrentHour\") ..\": \" ..tariffData.currentRate ..\" \" ..self.currency ..\" (\" ..prevDiff ..\" \" ..prevDir ..\") - \" ..self.i18n:get(rank) ..\"\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(nextRank) ..\" \" ..self.i18n:get(\"NextHour\") ..\": \" ..tariffData.nextRate ..\" \" ..self.currency ..\" (\" ..rateDiff ..\" \" ..nextDir ..\") - \" ..self.i18n:get(nextRank) ..\"\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(avgDayRank) ..\" \" ..self.i18n:get(\"TodayAverage\") ..\": \" .. tariffData.avgDayRate ..\" \" ..self.currency ..\" - \" ..self.i18n:get(avgDayRank) ..\"\\n\\n\"\r\n\r\n    if (tariffData.avgNextDayRate == nil) then\r\n        labelInfo = labelInfo ..self.i18n:get(\"TomorrowRatesReleases\") ..\" \" ..self:getRateReleaseTime(self.timezoneOffset) ..\" (UTC: \" ..self:getRateReleaseTime(0) ..\")\\n\"\r\n        labelInfo = labelInfo ..\"🕓 \" ..self.i18n:get(\"TomorrowAverage\") ..\": --\\n\\n\"\r\n    else\r\n        local avgNextDayRank = self:getRank(tariffData.avgNextDayRate)\r\n        labelInfo = labelInfo ..self.i18n:get(\"TomorrowRateRange\") ..\": \" ..tariffData.minNextDayRate ..\" \" ..self.i18n:get(\"To\") ..\" \" ..tariffData.maxNextDayRate ..\" \" ..self.currency ..\"\\n\"\r\n        labelInfo = labelInfo ..self:getRankIcon(avgNextDayRank) ..\" \" ..self.i18n:get(\"TomorrowAverage\") ..\": \" ..tariffData.avgNextDayRate ..\" \" ..self.currency ..\" - \" ..self.i18n:get(avgNextDayRank) ..\"\\n\\n\"\r\n    end\r\n\r\n    labelInfo = labelInfo ..self.i18n:get(\"TariffRatePeriod\") ..\": \" ..string.sub(tariffData.firstRate, 1, 10) ..\" -- \" ..string.sub(tariffData.lastRate, 1, 10) ..\"\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(avgMonthRank) ..\" \" ..self.i18n:get(\"ThisMonthAverage\") .. \": \" ..tariffData.avgMonthRate ..\" \" ..self.currency ..\" (\" ..string.format(\"%.0f\", tariffData.avgMonthCount/24) ..\" \" ..self.i18n:get(\"Days\") ..\")\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(avgTotalRank) ..\" \" ..self.i18n:get(\"TotalTariffAverage\") .. \": \" ..tariffData.avgTotalRate ..\" \" ..self.currency ..\" (\" ..string.format(\"%.0f\", tariffData.count/24) ..\" \"  ..self.i18n:get(\"Days\") ..\")\" ..\"\\n\"\r\n\r\n    labelInfo = labelInfo ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"EnergyArea\") ..\": \" ..areaName ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"AreaCode\") ..\": \" ..self.areaCode ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"TariffRateHistory\") ..\": \" ..self.tariffHistory ..\" \" ..self.i18n:get(\"days\") ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"MediumRatePrice\") ..\": \" ..self.mediumPrice ..\" \" ..self.currency ..\"/kWh\\n\"\r\n\r\n    labelInfo = labelInfo ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"EnergyRateUpdate\") ..\": \" ..self.serviceRequestTime ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"VariableUpdate\") ..\": \" ..lastUpd ..\"\\n\"\r\n\r\n    if (self.currency ~= \"EUR\") then -- Only show if exchange currency is not in Euro\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"ExchangeRate\") ..\": 1 EUR = \" .. exchangeRate .. \" \" .. self.currency\r\n    end\r\n\r\n    if (self.tax > 0) then -- Only show if Tax is set\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"Tax\") ..\": \" ..string.format(\"%.0f\", self.tax * 100) ..\"%\"\r\n    end\r\n\r\n    if not (self.i18n.isTranslated) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..\"⚠️ \" ..self.i18n:get(\"MissingTranslation\") ..\": \" ..self.i18n.languageCode\r\n    end\r\n\r\n    self:updateView(\"labelInfo\", \"text\", labelInfo)\r\n\r\n    self:d(\"Current (\" ..self.i18n:get(rank) ..\") Rate: \" ..tariffData.currentRate ..\" \" ..self.currency ..\"/kWh\" ..\", Next (\" ..nextRank ..\") Rate: \" ..tariffData.nextRate ..self.currency ..\"/kWh\" ..\" (\" ..rateDiff ..nextDir ..\")\")\r\nend"},{"name":"exchangeRate","isMain":false,"isOpen":false,"content":"-- Exchange rates API is a simple and lightweight free service for current and historical foreign exchange rates & crypto exchange rates.\r\n-- Reliable and up-to-date EU VAT rates, sourced directly from the European Commission's databases.\r\n-- If you like it, donate a cappuccino https://exchangerate.host/#/donate ;)\r\n\r\n-- Service home site: https://exchangerate.host\r\n\r\nfunction QuickApp:setExchangeRate(responseData)\r\n    if responseData == nil then\r\n        self:debug(\"Exchange Rate: Error when request rate!\")\r\n    end\r\n\r\n    for curr, value in pairs(responseData.rates) do\r\n        self.exchangeRate = tonumber(value)\r\n        self:d(\"Exchange Rate: 1 EUR = \" .. value .. \" \" .. curr)\r\n    end\r\nend\r\n\r\nfunction QuickApp:getServiceExchangeData(callback, instance)\r\n    -- Request exchangerate.host with base currency \"EUR\" that always is ENTSO-e response currency\r\n    local url = self.exchangerate_baseURL .. \"latest?base=EUR&symbols=\" .. self.currency .. \"&amount=1\"\r\n    self.httpClient:request(url, {\r\n        options = {\r\n            method = \"GET\",\r\n            headers = {[\"Accept\"] = \"application/json\"}\r\n        },\r\n        success = function(response)\r\n            local success, data = pcall(function()\r\n                                            return json.decode(response.data)\r\n                                        end)\r\n\r\n            if success then\r\n                pcall(callback, instance, data)\r\n            else\r\n                self:debug(\"Broken json response from Url: \" .. url)\r\n                return nil\r\n            end\r\n        end,\r\n        error = function(message)\r\n            self:debug(\"Error:\", message)\r\n            return nil\r\n        end\r\n    })\r\nend\r\n"},{"name":"entsoe_GetDayPrice","isMain":false,"isOpen":false,"content":"-- https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_generation_domain\r\n-- 4.2.10. Day Ahead Rates [12.1.D]\r\n\r\nfunction QuickApp:getServiceRateData(callback, instance, fromdate, todate)\r\n    self:d(\"Request ENTSO-e for period UTC: \" .. fromdate .. \" -- \" .. todate .. \" (AreaCode: \" .. self.areaCode .. \")\")\r\n\r\n    local ratePrice = {}\r\n    local ratePrices = {}\r\n    local rateTable = {}\r\n    local url = self.entsoe_baseURL .. \"?documentType=A44&in_Domain=\" .. self.areaCode .. \"&out_Domain=\" .. self.areaCode .. \"&periodStart=\" .. fromdate .. \"&periodEnd=\" .. todate .. \"&securityToken=\" .. self.token\r\n\r\n    self.httpClient:request(url, {\r\n        options = {\r\n            method = \"GET\",\r\n            headers = {\r\n                [\"SECURITY_TOKEN\"] = self.token,\r\n                [\"Accept\"] = \"text/xml\"\r\n            }\r\n        },\r\n        success = function(response)\r\n            -- Create Rate table from XML response\r\n            local periodXml = self:getXmlElement(response.data, \"Period\")\r\n            local success, data = pcall(function()\r\n                                            return self:xml2PriceTable(periodXml)\r\n                                        end)                                        \r\n            if success then\r\n                if data == nil then \r\n                    self.serviceSuccess = false\r\n                    self.serviceMessage = \"ERROR: Empty response from Url \" ..url\r\n                    self:debug(self.serviceMessage)\r\n                    return nil\r\n                end\r\n\r\n                -- Get UTC start and end date from response XML\r\n                local startDate = self:getXmlDate(periodXml, \"start\", \"%Y-%m-%d %H:%M\")\r\n                local endDate = self:getXmlDate(periodXml, \"end\", \"%Y-%m-%d %H:%M\")\r\n\r\n                -- Create (UTC) date and rate table\r\n                for index, rate in pairs(data) do\r\n                    ratePrice = {\r\n                        rateDate = self:getRateDate(startDate, \"%Y-%m-%d %H:%M\", index - 1),\r\n                        rateTime = self:getRateDate(startDate, \"%d.%H\", index - 1),\r\n                        rate = rate\r\n                    }\r\n                    table.insert(ratePrices, ratePrice)\r\n                end\r\n\r\n                self:d(\"=> Response: Start UTC = \" .. startDate .. \", End UTC = \" .. endDate .. \", \" .. self:tableCount(ratePrices) .. \" rates\")\r\n                \r\n                self.serviceSuccess = true\r\n                self.serviceMessage = \"\" \r\n                pcall(callback, instance, ratePrices)\r\n            else\r\n                self.serviceSuccess = false\r\n                self.serviceMessage = \"Error: Broken xml response from Url \" ..url\r\n                self:debug(self.serviceMessage)\r\n                return nil\r\n            end\r\n        end,\r\n        error = function(message)\r\n            self.serviceSuccess = false\r\n            self.serviceMessage = \"Error: \" ..message\r\n            self:debug(self.serviceMessage)\r\n            return nil\r\n        end\r\n    })\r\nend\r\n"},{"name":"entsoe_AreaCodes","isMain":false,"isOpen":false,"content":"-- See \"BZN\" Area codes at: https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_areas\r\n\r\nfunction QuickApp:createAreaVariables()\r\n    local level_var = {\r\n            name=self.global_var_area_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=self.default_area_name,\r\n            enumValues={\"Austria (AT)\",\"Belgium (BE)\",\"Bosnia and Herz. (BA)\",\"Bulgaria (BG)\",\"Croatia (HR)\",\"Czech Republic (CZ)\",\"Denmark (DK1)\",\"Denmark (DK2)\",\"Estonia (EE)\",\"Finland (FI)\",\"France (FR)\",\"Germany (DE-LU)\",\"Greece (GR)\",\"Hungary (HU)\",\"Ireland (SEM)\",\"Italy (Calabria)\",\"Italy (SACOAC)\",\"Italy (SACODC)\",\"Italy (Centre-North)\",\"Italy (Centre-South)\",\"Italy (North)\",\"Italy (Sardinia)\",\"Italy (Sicily)\",\"Italy (South)\",\"Latvia (LV)\",\"Lithuania (LT)\",\"Luxembourg (LU)\",\"Netherlands (NL)\",\"North Macedonia (MK)\",\"Norway (NO1)\",\"Norway (NO2)\",\"Norway (NO2NSL)\",\"Norway (NO3)\",\"Norway (NO4)\",\"Norway (NO5)\",\"Poland (PL)\",\"Portugal (PT)\",\"Romania (RO)\",\"Serbia (RS)\",\"Slovakia (SK)\",\"Slovenia (SI)\",\"Spain (ES)\",\"Sweden (SE1)\",\"Sweden (SE2)\",\"Sweden (SE3)\",\"Sweden (SE4)\",\"Switzerland (CH)\",\"Ukraine (UA-IPS)\",\"United Kingdom (GB)\"}\r\n    }\r\n    api.post('/globalVariables/',level_var)    \r\nend\r\n\r\nfunction QuickApp:getAreaCode(areaName)\r\n    -- Set default Area code if \"areaName\" is missing.\r\n    if areaName == nil or areaName == \"\" then areaName = self.default_area_name end\r\n    \r\n    if (areaName == \"Austria (AT)\") then return \"10YAT-APG------L\" end\r\n    if (areaName == \"Belgium (BE)\") then return \"10YBE----------2\" end\r\n    if (areaName == \"Bosnia and Herz. (BA)\") then return \"10YBA-JPCC-----D\" end\r\n    if (areaName == \"Bulgaria (BG)\") then return \"10YCA-BULGARIA-R\" end\r\n    if (areaName == \"Croatia (HR)\") then return \"10YHR-HEP------M\" end\r\n    if (areaName == \"Czech Republic (CZ)\") then return \"10YCZ-CEPS-----N\" end\r\n    if (areaName == \"Denmark (DK1)\") then return \"10YDK-1--------W\" end\r\n    if (areaName == \"Denmark (DK2)\") then return \"10YDK-2--------M\" end\r\n    if (areaName == \"Estonia (EE)\") then return \"10Y1001A1001A39I\" end\r\n    if (areaName == \"Finland (FI)\") then return \"10YFI-1--------U\" end\r\n    if (areaName == \"France (FR)\") then return \"10YFR-RTE------C\" end\r\n    if (areaName == \"Germany (DE-LU)\") then return \"10Y1001A1001A82H\" end\r\n    if (areaName == \"Greece (GR)\") then return \"10YGR-HTSO-----Y\" end\r\n    if (areaName == \"Hungary (HU)\") then return \"10YHU-MAVIR----U\" end\r\n    if (areaName == \"Ireland (SEM)\") then return \"10Y1001A1001A59C\" end\r\n    if (areaName == \"Italy (Calabria)\") then return \"10Y1001C--00096J\" end\r\n    if (areaName == \"Italy (Centre-North)\") then return \"10Y1001A1001A70O\" end\r\n    if (areaName == \"Italy (Centre-South)\") then return \"10Y1001A1001A71M\" end\r\n    if (areaName == \"Italy (North)\") then return \"10Y1001A1001A73I\" end\r\n    if (areaName == \"Italy (SACOAC)\") then return \"10Y1001A1001A885\" end\r\n    if (areaName == \"Italy (SACODC)\") then return \"10Y1001A1001A893\" end\r\n    if (areaName == \"Italy (Sardinia)\") then return \"10Y1001A1001A74G\" end\r\n    if (areaName == \"Italy (Sicily)\") then return \"10Y1001A1001A75E\" end\r\n    if (areaName == \"Italy (South)\") then return \"10Y1001A1001A788\" end\r\n    if (areaName == \"Latvia (LV)\") then return \"10YLV-1001A00074\" end\r\n    if (areaName == \"Lithuania (LT)\") then return \"10YLT-1001A0008Q\" end\r\n    if (areaName == \"Luxembourg (LU)\") then return \"10Y1001A1001A82H\" end\r\n    if (areaName == \"Netherlands (NL)\") then return \"10YNL----------L\" end\r\n    if (areaName == \"North Macedonia (MK)\") then return \"10YMK-MEPSO----8\" end\r\n    if (areaName == \"Norway (NO1)\") then return \"10YNO-1--------2\" end\r\n    if (areaName == \"Norway (NO2)\") then return \"10YNO-2--------T\" end\r\n    if (areaName == \"Norway (NO2NSL)\") then return \"50Y0JVU59B4JWQCU\" end\r\n    if (areaName == \"Norway (NO3)\") then return \"10YNO-3--------J\" end\r\n    if (areaName == \"Norway (NO4)\") then return \"10YNO-4--------9\" end\r\n    if (areaName == \"Norway (NO5)\") then return \"10Y1001A1001A48H\" end\r\n    if (areaName == \"Poland (PL)\") then return \"10YPL-AREA-----S\" end\r\n    if (areaName == \"Portugal (PT)\") then return \"10YPT-REN------W\" end\r\n    if (areaName == \"Romania (RO)\") then return \"10YRO-TEL------P\" end\r\n    if (areaName == \"Serbia (RS)\") then return \"10YCS-SERBIATSOV\" end\r\n    if (areaName == \"Slovakia (SK)\") then return \"10YSK-SEPS-----K\" end\r\n    if (areaName == \"Slovenia (SI)\") then return \"10YSI-ELES-----O\" end\r\n    if (areaName == \"Spain (ES)\") then return \"10YES-REE------0\" end\r\n    if (areaName == \"Sweden (SE1)\") then return \"10Y1001A1001A44P\" end\r\n    if (areaName == \"Sweden (SE2)\") then return \"10Y1001A1001A45N\" end\r\n    if (areaName == \"Sweden (SE3)\") then return \"10Y1001A1001A46L\" end\r\n    if (areaName == \"Sweden (SE4)\") then return \"10Y1001A1001A47J\" end\r\n    if (areaName == \"Switzerland (CH)\") then return \"10YCH-SWISSGRIDZ\" end\r\n    if (areaName == \"Ukraine (UA-IPS)\") then return \"10Y1001C--000182\" end\r\n    if (areaName == \"United Kingdom (GB)\") then return \"10YGB----------A\" end\r\n\r\n    return \"\" -- No match\r\nend"},{"name":"i18n","isMain":false,"isOpen":false,"content":"class \"i18n\"\r\n\r\nphrases = {\r\n    en = {\r\n        [\"Refreshing\"] = \"Refreshing\",\r\n        [\"LoadingEnergyRates\"] = \"Loading energy rates\",\r\n        [\"Refresh\"] = \"Refresh\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Missing Energy rates for selected energy area\",\r\n        [\"ExchangeRate\"] = \"Exchange rate\",\r\n        [\"TodayRates\"] = \"Todays rates\",\r\n        [\"Range\"] = \"Range\",\r\n        [\"To\"] = \"to\",\r\n        [\"CurrentHour\"] = \"Current hour\",\r\n        [\"NextHour\"] = \"Next hour\",\r\n        [\"TodayAverage\"] = \"Today average\",\r\n        [\"TomorrowRatesReleases\"] = \"Tomorrow rates releases\",\r\n        [\"TomorrowAverage\"] = \"Tomorrow average\",\r\n        [\"TomorrowRateRange\"] = \"Tomorrow rate range\",\r\n        [\"TariffRatePeriod\"] = \"Tariff rate period\",\r\n        [\"ThisMonthAverage\"] = \"This month average\",\r\n        [\"TotalTariffAverage\"] = \"Total tariff average\",\r\n        [\"Days\"] = \"Days\",\r\n        [\"days\"] = \"days\",\r\n        [\"EnergyArea\"] = \"Energy area\",\r\n        [\"AreaCode\"] = \"ENTSO-e AreaCode\",\r\n        [\"LanguageCode\"] = \"Language Code\",\r\n        [\"TariffRateHistory\"] = \"Tariff rate history\",\r\n        [\"MediumRatePrice\"] = \"Medium rate price\",\r\n        [\"Tax\"] = \"Energy prices include tax of\",\r\n        [\"EnergyRateUpdate\"] = \"Energy rate update\",\r\n        [\"VariableUpdate\"] = \"Variable update\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    },\r\n    dk = {\r\n        [\"Refreshing\"] = \"Opdatering\",\r\n        [\"LoadingEnergyRates\"] = \"Indlæsning af energisatser\",\r\n        [\"Refresh\"] = \"Opdatering\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Manglende energisatser for udvalgt energiområde\",\r\n        [\"ExchangeRate\"] = \"Valutakurs\",\r\n        [\"TodayRates\"] = \"I dag kurser\",\r\n        [\"Range\"] = \"Rækkevidde\",\r\n        [\"To\"] = \"til\",\r\n        [\"CurrentHour\"] = \"Aktuel time\",\r\n        [\"NextHour\"] = \"Næste time\",\r\n        [\"TodayAverage\"] = \"Dagens gennemsnit\",\r\n        [\"TomorrowRatesReleases\"] = \"Priserne i morgen offentliggøres\",\r\n        [\"TomorrowAverage\"] = \"Morgendagens gennemsnit\",\r\n        [\"TomorrowRateRange\"] = \"Prisinterval i morgen\",\r\n        [\"TariffRatePeriod\"] = \"Tarifperiode\",\r\n        [\"ThisMonthAverage\"] = \"Gennemsnit i denne måned\",\r\n        [\"TotalTariffAverage\"] = \"Samlet tarifgennemsnit\",\r\n        [\"Days\"] = \"Dage\",\r\n        [\"days\"] = \"dage\",\r\n        [\"EnergyArea\"] = \"Energiområde\",\r\n        [\"AreaCode\"] = \"ENTSO-e Områdenummer\",\r\n        [\"LanguageCode\"] = \"Sprogkode\",\r\n        [\"TariffRateHistory\"] = \"Tarifhistorie\",\r\n        [\"MediumRatePrice\"] = \"Mellempris pris\",\r\n        [\"Tax\"] = \"Priserne er inklusive moms\",\r\n        [\"EnergyRateUpdate\"] = \"Energirate opdatering\",\r\n        [\"VariableUpdate\"] = \"Variabel opdatering\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    },\r\n    no = {\r\n        [\"Refreshing\"] = \"Oppdaterer\",\r\n        [\"LoadingEnergyRates\"] = \"Laster spotpriser\",\r\n        [\"Refresh\"] = \"Oppdater\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Spotpriser mangler for valgt energiområde\",\r\n        [\"ExchangeRate\"] = \"Vekslingskurs\",\r\n        [\"TodayRates\"] = \"Dagens priser\",\r\n        [\"Range\"] = \"Område\",\r\n        [\"To\"] = \"til\",\r\n        [\"CurrentHour\"] = \"Aktuell time\",\r\n        [\"NextHour\"] = \"Neste time\",\r\n        [\"TodayAverage\"] = \"Dagens gjennomsnittsverdi\",\r\n        [\"TomorrowRatesReleases\"] = \"Morgendagens priser er sluppet\",\r\n        [\"TomorrowAverage\"] = \"Morgendagens gjennomsnitt\",\r\n        [\"TomorrowRateRange\"] = \"Morgendagens omfang\",\r\n        [\"TariffRatePeriod\"] = \"Tariffperiode\",\r\n        [\"ThisMonthAverage\"] = \"Nåværende måneds gjennomsnitt\",\r\n        [\"TotalTariffAverage\"] = \"Gjennomsnittlig verdi totalt sett\",\r\n        [\"Days\"] = \"Dager\",\r\n        [\"days\"] = \"dager\",\r\n        [\"EnergyArea\"] = \"Energiområde\",\r\n        [\"AreaCode\"] = \"Områdeskode (ENTSO-e)\",\r\n        [\"LanguageCode\"] = \"Språkkode\",\r\n        [\"TariffRateHistory\"] = \"Tariffhistorie\",\r\n        [\"MediumRatePrice\"] = \"Gjennomsnittspris\",\r\n        [\"Tax\"] = \"Prisene inkluderer skatt\",\r\n        [\"EnergyRateUpdate\"] = \"Spotpriser sist oppdatert\",\r\n        [\"VariableUpdate\"] = \"Variabler sist oppdatert\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    },\r\n    sv = {\r\n        [\"Refreshing\"] = \"Uppdaterar\",\r\n        [\"LoadingEnergyRates\"] = \"Laddar spotpriser\",\r\n        [\"Refresh\"] = \"Uppdatera\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Spotpriser saknas för valt energiområde\",\r\n        [\"ExchangeRate\"] = \"Växlingskurs\",\r\n        [\"TodayRates\"] = \"Dagens priser\",\r\n        [\"Range\"] = \"Omfång\",\r\n        [\"To\"] = \"till\",\r\n        [\"CurrentHour\"] = \"Innevarande timme\",\r\n        [\"NextHour\"] = \"Kommande timme\",\r\n        [\"TodayAverage\"] = \"Dagens medelvärde\",\r\n        [\"TomorrowRatesReleases\"] = \"Morgondagens priser släpps\",\r\n        [\"TomorrowAverage\"] = \"Morgondagens medelvärde\",\r\n        [\"TomorrowRateRange\"] = \"Morgondagens omfång\",\r\n        [\"TariffRatePeriod\"] = \"Tariffperiod\",\r\n        [\"ThisMonthAverage\"] = \"Innevarande månads medelvärde\",\r\n        [\"TotalTariffAverage\"] = \"Medelvärde totalt\",\r\n        [\"Days\"] = \"Dagar\",\r\n        [\"days\"] = \"dagar\",\r\n        [\"EnergyArea\"] = \"Energiområde\",\r\n        [\"AreaCode\"] = \"Områdeskod (ENTSO-e)\",\r\n        [\"LanguageCode\"] = \"Språkkod\",\r\n        [\"TariffRateHistory\"] = \"Tariff historik\",\r\n        [\"MediumRatePrice\"] = \"Medelpris\",\r\n        [\"Tax\"] = \"Priserna inkluderar skatt med\",\r\n        [\"EnergyRateUpdate\"] = \"Spotpriser senast uppdaterade\",\r\n        [\"VariableUpdate\"] = \"Variabler senast uppdaterade\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    }\r\n}\r\n\r\nfunction i18n:new(langCode)\r\n    self.isTranslated = true\r\n    if phrases[langCode] == nil then \r\n        langCode = \"en\"\r\n        self.isTranslated = false\r\n    end\r\n    self.languageCode = langCode\r\n    self.phrases = phrases[langCode]\r\n    return self\r\nend\r\n\r\nfunction i18n:get(key)\r\n    if key == nil then return \"\" end\r\n    if self.phrases[key] then return self.phrases[key] end\r\n    return key\r\nend"},{"name":"fibaroTariffRate","isMain":false,"isOpen":false,"content":"function QuickApp:updateFibaroTariffTable(energyRateTable)\r\n    -- Exit if no data\r\n    if self:tableCount(energyRateTable) == 0 then return end\r\n    if self.tariffHistory == nil then self.tariffHistory = 365 end\r\n\r\n    -- Get current FIBARO Energy Tariff data\r\n    local tariffData = api.get(\"/energy/billing/tariff\")\r\n    local tariff = {}\r\n    local addTariffs = tariffData.additionalTariffs\r\n    local tblCount = self:tableCount(addTariffs)\r\n    local rate = tariffData.rate\r\n    local updateTariff = false\r\n    local maxHoursInTariff = self.tariffHistory * 24\r\n    \r\n    -- If reset Tariff rates button have been pressed\r\n    if (updateTariff) then\r\n        addTariffs = {}\r\n        self:d(\"Reset FIBARO Tariff rates!\")\r\n    end\r\n\r\n    -- Create Additional Tariff table in kWh/local currency and timezone\r\n    local totalRate = 0;\r\n    for index, rateData in pairs(energyRateTable) do\r\n        local tariffName = self:getRateDate(rateData.rateDate, \"%Y-%m-%d %H:%M\", 0, self.timezoneOffset)\r\n        local calcRate = self:getLocalTariffRate(rateData.rate, self.exchangeRate, self.tax)\r\n        totalRate = totalRate + calcRate\r\n\r\n        if updateTariff or not (self:existsInFibaroTariffTable(addTariffs, tariffName)) then\r\n            tariff = {\r\n                name = tariffName,\r\n                rate = calcRate,\r\n                startTime = self:getRateDate(rateData.rateDate, \"%H:%M\", 0, self.timezoneOffset),\r\n                endTime = self:getRateDate(rateData.rateDate, \"%H:%M\", 1, self.timezoneOffset),\r\n                days = {string.lower(self:getRateDate(rateData.rateDate, \"%A\", 0, self.timezoneOffset))}\r\n            }\r\n            table.insert(addTariffs, tariff)\r\n            updateTariff = true\r\n        end\r\n    end\r\n   \r\n    -- Update FIBARO Tariff table if need to clean history\r\n    if (tblCount > maxHoursInTariff) then updateTariff = true end\r\n\r\n    -- If all rates in response table is 0 then do not update FIBARO Tariff table, something is wrong!\r\n    if (totalRate == 0) then\r\n        updateTariff = false\r\n        self.serviceSuccess = false -- Something got wrong in ENTSO-e request\r\n    end\r\n\r\n    -- Update FIBARO tariff rates with new Tariff data\r\n    if updateTariff then       \r\n        -- Sort tariff table by name (DateTime)\r\n        table.sort(addTariffs, function (t1, t2) return t1.name < t2.name end )\r\n\r\n        -- Clean old Tartiff rates\r\n        if (maxHoursInTariff > 0 and maxHoursInTariff < tblCount) then\r\n            local cleanTariffs = {}\r\n            local startIndex = tblCount - maxHoursInTariff\r\n            for index, tariff in pairs(addTariffs) do\r\n                if index > startIndex then\r\n                    table.insert(cleanTariffs, tariff)\r\n                end\r\n            end\r\n            addTariffs = cleanTariffs\r\n            self:d(\"Tariff table clean from old history: \" ..startIndex ..\" hours\")\r\n        end\r\n\r\n        -- Get current rate from FIBARO Tariff rates\r\n        local currentTariff = self:getFibaroTariff(addTariffs, os.date(\"%Y-%m-%d %H:00\", os.time()))\r\n        if (currentTariff ~= nil) then\r\n            if (rate ~= currentTariff.rate) then updateTariff = true end\r\n            rate = currentTariff.rate\r\n            self:d(\"Set new Tariff rate: \" ..rate ..\" \" ..self.currency)\r\n        end    \r\n\r\n        -- Save new tariff table to FIBARO\r\n        local response, code = api.put(\"/energy/billing/tariff\", {\r\n            returnRate = tariffData.returnRate,\r\n            additionalTariffs = addTariffs,\r\n            name = tariffData.name,\r\n            rate = rate\r\n        })\r\n\r\n        self:d(\"Update Tariff response \" .. tostring(code) .. \" - \\\"\" .. tariffData.name .. \"\\\" Rate: \" .. tariffData.rate .. \" => \" .. rate .. \" (TimezoneOffset: \" .. self.timezoneOffset .. \")\")\r\n    end\r\nend\r\n\r\nfunction QuickApp:getFibaroTariffData()\r\n    -- Get current FIBARO Energy Tariff data\r\n    local tariffData = api.get(\"/energy/billing/tariff\")\r\n\r\n    local dateFormat = \"%Y-%m-%d %H:00\"\r\n    local dayDate = os.date(\"%Y-%m-%d\")\r\n    local nextDayDate = os.date(\"%Y-%m-%d\", os.time() + 86400)\r\n    local monthDate = os.date(\"%Y-%m\")\r\n    local timeShift = 1 * 60 * 60  -- 1 hours\r\n    local previousRate = 0\r\n    local currentRate = 0\r\n    local nextRate = 0\r\n    local totalCount = 0\r\n    local totalRate = 0\r\n    local totalDayCount = 0\r\n    local totalDayRate = 0\r\n    local totalMonthCount = 0\r\n    local totalMonthRate = 0\r\n    local minDayRate = 9999\r\n    local maxDayRate = 0\r\n    local totalNextDayCount = 0\r\n    local totalNextDayRate = 0    \r\n    local minNextDayRate = 9999\r\n    local maxNextDayRate = 0\r\n    local avgNextDayRate = nil\r\n    local first = \"\"\r\n    local last = \"\"\r\n\r\n    -- TODO: Get AvgDay, AvgTotal, AvgComming, AvgMonth\r\n    -- For each FIBARO tariff rates\r\n    if (self:tableCount(tariffData.additionalTariffs) > 0) then\r\n        for index, tariff in pairs(tariffData.additionalTariffs) do\r\n            -- Set first and last name\r\n            if index == 1 then first = tariff.name end\r\n            last = tariff.name\r\n\r\n            -- Set total values\r\n            totalRate = totalRate + tariff.rate\r\n            totalCount = totalCount + 1\r\n\r\n            -- Set today values\r\n            if (string.sub(tariff.name, 1, 10) == dayDate) then\r\n                totalDayRate = totalDayRate + tariff.rate\r\n                totalDayCount = totalDayCount + 1\r\n                if tariff.rate < minDayRate then minDayRate = tariff.rate end\r\n                if tariff.rate > maxDayRate then maxDayRate = tariff.rate end\r\n            end\r\n            \r\n            -- Set current month values\r\n            if (string.sub(tariff.name, 1, 7) == monthDate) then\r\n                totalMonthRate = totalMonthRate + tariff.rate\r\n                totalMonthCount = totalMonthCount + 1\r\n            end\r\n\r\n            -- Set tomorrow values\r\n            if (string.sub(tariff.name, 1, 10) == nextDayDate) then\r\n                totalNextDayRate = totalNextDayRate + tariff.rate\r\n                totalNextDayCount = totalNextDayCount + 1\r\n                if tariff.rate < minNextDayRate then minNextDayRate = tariff.rate end\r\n                if tariff.rate > maxNextDayRate then maxNextDayRate = tariff.rate end\r\n            end\r\n\r\n            -- Set previous, current and next rate values\r\n            if (tariff.name == os.date(dateFormat, os.time() - timeShift))    then previousRate = tariff.rate end\r\n            if (tariff.name == os.date(dateFormat, os.time()))                then currentRate = tariff.rate end\r\n            if (tariff.name == os.date(dateFormat, os.time() + timeShift))    then nextRate = tariff.rate end\r\n        end\r\n\r\n        -- Calculate tomorrow average values\r\n        if (totalNextDayCount > 0) then avgNextDayRate = string.format(\"%.2f\", tonumber(totalNextDayRate / totalNextDayCount)) end\r\n\r\n        -- Update FIBARO tariff rate with current rate if not same\r\n        if (tariffData.rate ~= currentRate) then\r\n            local response, code = api.put(\"/energy/billing/tariff\", {\r\n                returnRate = tariffData.returnRate,\r\n                additionalTariffs = tariffData.additionalTariffs,\r\n                name = tariffData.name,\r\n                rate = currentRate\r\n            })\r\n\r\n            self:d(\"Update Tariff response \" .. tostring(code) .. \" - \\\"\" .. tariffData.name .. \"\\\" Rate: \" .. tariffData.rate .. \" => \" .. currentRate)\r\n        end\r\n    end\r\n\r\n    -- Set return Tariff Data table\r\n    local tariffData = {\r\n        count = totalCount,\r\n        previousRate = previousRate,\r\n        currentRate = currentRate,\r\n        nextRate = nextRate,\r\n        avgTotalRate = string.format(\"%.2f\", tonumber(totalRate / totalCount)),\r\n        avgDayRate = string.format(\"%.2f\", tonumber(totalDayRate / totalDayCount)),\r\n        avgDayCount = totalDayCount,\r\n        avgMonthRate = string.format(\"%.2f\", tonumber(totalMonthRate / totalMonthCount)),\r\n        avgMonthCount = totalMonthCount,\r\n        minDayRate = minDayRate,\r\n        maxDayRate = maxDayRate,\r\n        avgNextDayRate = avgNextDayRate,\r\n        minNextDayRate = minNextDayRate,\r\n        maxNextDayRate = maxNextDayRate,        \r\n        firstRate = first,\r\n        lastRate = last\r\n    }\r\n\r\n    self:d(\"TariffData - Count: \" ..tariffData.count ..\" (\" ..(self.tariffHistory * 24) ..\"), Previous Rate: \" ..tariffData.previousRate ..\", Current Rate: \" ..tariffData.currentRate ..\", next Rate: \" ..tariffData.nextRate ..\", Total avrage Rate: \" ..tariffData.avgTotalRate)\r\n\r\n    return tariffData\r\nend\r\n\r\nfunction QuickApp:IsFibaroTariffUpToDate()\r\n    -- Get current FIBARO Energy Tariff data\r\n    local tariffData = api.get(\"/energy/billing/tariff\")\r\n\r\n    if self.tariffHistory == nil then self.tariffHistory = 365 end\r\n    local maxHoursInTariff = self.tariffHistory * 24\r\n    local tblCount = self:tableCount(tariffData.additionalTariffs)\r\n    local dateFormat = \"%Y-%m-%d %H:00\"\r\n    local timeShift = 1 * 60 * 60      -- 1 hours\r\n    local nextDayShift = 24 * 60 * 60  -- 24 hours\r\n    local keepHistory = false\r\n    local previousExists = false\r\n    local currentExist = false\r\n    local nextExists = false\r\n    local nextDayExists = true\r\n\r\n    if (tblCount > maxHoursInTariff) then \r\n        self:d(\"FIBARO Tariff rate panel need to be cleaned!\")\r\n        return false\r\n    end\r\n\r\n    -- ENTSO-e relese next day energy rate prices after 12:00 UTC each day\r\n    if (tonumber(os.date(\"!%H\", os.time())) >= 12) then nextDayExists = false end\r\n\r\n    for _, tariff in pairs(tariffData.additionalTariffs) do\r\n        if (tariff.name == os.date(dateFormat, os.time() - timeShift))    then previousExists = true end\r\n        if (tariff.name == os.date(dateFormat, os.time()))                then currentExist = true end\r\n        if (tariff.name == os.date(dateFormat, os.time() + timeShift))    then nextExists = true end\r\n        if (tariff.name == os.date(dateFormat, os.time() + nextDayShift)) then nextDayExists = true end\r\n        \r\n        if previousExists and currentExist and nextExists and nextDayExists then\r\n            self:d(\"FIBARO Tariff rate panel is already up to date\")\r\n            return true\r\n        end   \r\n    end\r\n\r\n    self:d(\"FIBARO Tariff rate panel need to be updated!\")\r\n    return false\r\nend\r\n\r\nfunction QuickApp:existsInFibaroTariffTable(table, match)\r\n    for _, data in pairs(table) do\r\n        if (data.name == match) then return true end\r\n    end\r\n    self:d(\"Fibaro Tariff \" ..match ..\" not exists!\")\r\n    return false\r\nend\r\n\r\nfunction QuickApp:getFibaroTariff(rates, match)\r\n    for _, data in pairs(rates) do\r\n        if (data.name == match) then return data end\r\n    end\r\n    self:d(\"Fibaro Tariff \" ..match ..\" is missing!\")\r\n    return nil\r\nend\r\n"}]}