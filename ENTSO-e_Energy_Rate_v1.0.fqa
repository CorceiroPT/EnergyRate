{"name":"ENTSO-e Energy Rate","type":"com.fibaro.multilevelSensor","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_704"},"sections":{"items":[{"components":[{"name":"labelInfo","style":{"weight":"1.2"},"text":"labelInfo","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"updateButton","style":{"weight":"1.2"},"text":"Refresh rates","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_704"}}},"uiCallbacks":[{"callback":"updateButton_action","eventType":"onReleased","name":"updateButton"}],"quickAppVariables":[{"name":"ENTSOE_Token","type":"string","value":"f442d0b3-450b-46d7-b752-d8d692fdb2c8"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":false,"content":"-- ENTSO-e Energy Rate is an QuickApp that is independent from any energy power company in Europe an it´s free to use at no cost.\n\n-- The only thing you need to do is register an user account at ENTSO-e Transparency Platform homesite and request for an Api Token. I´ve provide an Token for test purpose but can be changed in the future, so it´s highly recomended that you create your own token at ENTSO-e.\n-- Register an ENTSO-e account at: https://transparency.entsoe.eu/\n-- How to get an Token: https://transparency.entsoe.eu/content/static_content/download?path=/Static%20content/API-Token-Management.pdf\n\n-- The Exchange rate service (https://exchangerate.host) that is used in this QuickApp to get your local currency is also free to use and if you like it, donate a cappuccino https://exchangerate.host/#/donate ;)\n\n-- This is the first time I have developed in Lua language, so have some indulgence, but hey it works... for me ;)\n-- I would appreciate if you have any suggestions to make this QuickApp more usefull or if you find any bugs, please send me an email at energyrate@jamdata.com and I´ll try to do my best :)\n\nfunction QuickApp:onInit()\n    self.debugOn = false -- Write to debug console On/Off\n    self.httpClient = net.HTTPClient()\n\n    -- Variables for exchangerate.host Api service\n    -- https://exchangerate.host\n    self.exchangerate_baseURL = \"https://api.exchangerate.host/\"\n    self.exchangeRate = 0\n    self.currency = \"EUR\" -- This will be fetched later from Fibaro Settings when loading defaults\n\n    -- Variables for ENTSO-e Transparency Platform Api service\n    -- https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html\n    self.entsoe_baseURL = \"https://web-api.tp.entsoe.eu/api\"\n    self.child_rank_name = \"ENTSO-e Next Energy Rate\"\n    self.default_token_name = \"ENTSOE_Token\"\n    self.next_rank_device_id = nil\n    self.global_var_level_name = \"EnergyRateLevel\"\n    self.global_var_next_level_name = \"EnergyRateNextLevel\"\n    self.global_var_medium_rate_name = \"EnergyRateMedium\"\n    self.global_var_area_name = \"EnergyRateArea\"\n    self.default_area_name = \"Sweden (SE3)\" -- Sorry, but we need to set a default area, so now you now where I live :P\n\n    self.mediumRateValue = fibaro.getGlobalVariable(self.global_var_medium_rate_name)\n    self.areaName = fibaro.getGlobalVariable(self.global_var_area_name)\n    self.areaCode = self:getAreaCode(self.areaName)\n    self.serviceSuccess = true\n    \n    self.timezoneOffset = 0      -- This will be fetched later from Fibaro Settings when loading defaults\n    self.energyRateTable = {}    -- Energy rate local cache table (variables and panels are updated from this table)\n    self.serviceRateTable = {}   -- ENTSO-e service request table (temporary table when request ENTSO-e service)\n    self.serviceRequestTime = \"\" -- Last datetime when we request ENTSO-e service.\n\n    -- Let´s start\n    self:mainStart()\nend\n\nfunction QuickApp:mainStart()\n     -- An Access token is required from ENTSO-e to get this to work!\n     -- I'll provide you with one default Token, but I'd be very pleased if you get your own Token if you will use this QuickApp for a longer period.\n     -- Read how you get your own Token: https://transparency.entsoe.eu/content/static_content/download?path=/Static%20content/API-Token-Management.pdf\n     self.token = self:getVariable(self.default_token_name)\n\n     if self.token == nil or self.token == \"\" then\n        self:debug('No token provided!')\n        self:resetDisplayPanels(\"Access Token is required!\\n\\nAdd an access token key for ENTSO-E Web Api.\\nHow to get an Token: https://transparency.entsoe.eu/content/static_content/download?path=/Static%20content/API-Token-Management.pdf\")\n\n        -- Start this loop every minute until we got an Token\n        fibaro.setTimeout(60*1000, function()\n                                        self:mainStart()\n                                    end)\n    else       \n        -- Create global varaiables and set default values (See: defaults)\n        self:createGlobalVariables()\n        self:createAreaVariables()\n        self:setDefaultVariables()\n                \n        -- init Child device to display next rate in Fibaro (See: QAChild_NextRank)\n        self:initChildDevices({[\"com.fibaro.multilevelSensor\"] = ENTSOE_Next_Rank})\n        self:validateChildren()\n        \n        -- Start loops, one for ENTSO-e service and one for updating variables and panel.\n        self:d(\">>>> Start ENTSO-e Energy Rate <<<< \")\n        self:serviceRequestLoop(true) -- Request ExchangeRate and ENTSO-e serices\n        self:displayLoop(true)        -- Update variables and panel\n    end\nend\n\n-- Trigger if panel button pressed\nfunction QuickApp:updateButton_action()\n    self:d(\"Execute ENTSO-e service update on button event...\")\n    self.energyRateTable = {}\n    self:displayEnergyRate()\n    self:serviceRequestLoop(true)\n    self:displayLoop(true)\nend\n\n-- Variables and panel update display loop\nfunction QuickApp:displayLoop(first)\n    -- Set Update display loop to every full hour + 1 min\n    local loopTime = 10000\n    if not first then loopTime = (61 - tonumber(os.date(\"%M\"))) * 60 * 1000 end\n\n    -- Set Energy rates data to display\n    self:setEnergyRates()\n\n    -- Start this display loop\n    fibaro.setTimeout(loopTime, function() self:displayLoop(false) end)\nend\n\n-- ENTSO-e and Exchange rate service loop\nfunction QuickApp:serviceRequestLoop(first)\n    -- Set Update service request loop to every hour\n    local loopTime = (tonumber(os.date(\"%M\"))) * 60 * 1000\n    self.serviceSuccess = true\n    \n    -- Check if table is already up to date, otherwise request service and update table\n    if first or not self:IsTableUpToDate(self.energyRateTable, os.date(\"!%d.%H\")) then\n        self:refreshVariables() -- Refresh variable values\n        self.serviceRateTable = {}\n        \n        -- Get current Exchange rate from Exchangerate.host Api Service\n        self:getServiceExchangeData(QuickApp.setExchangeRate, self)\n        \n        -- Get Energy Rates from ENSO-e Api Service (wait 2 sec for Exchange rate http request to complete)\n        fibaro.setTimeout(2000, function() self:getRateData() end)\n    end\n\n    -- Start this Service request loop\n    fibaro.setTimeout(loopTime, function() self:serviceRequestLoop(false) end)\nend\n\nfunction QuickApp:getRateData()\n    local fromDate = os.date(\"!%Y%m%d0000\")\n    local toDate = os.date(\"!%Y%m%d2300\")\n\n    -- Get current day energy rates.\n    -- ENTSO-e Api only returns 24 hour Rate list on each request even if we define another \"toDate\" :(\n    self:getServiceRateData(QuickApp.addEnergyRates, self, fromDate, toDate)\n\n    -- Get next 24 hour energy rates if they have been released.\n    -- Normally the next day energy rates are released after 12:00 UTC.\n    -- We only need the next day rates to solve the midnight shift between 23:00 and 00:00.\n    if (self.serviceSuccess and tonumber(os.date(\"!%H\", os.time())) > 14) then\n        fromDate = os.date(\"!%Y%m%d0000\", os.time() + 86400)\n        toDate = os.date(\"!%Y%m%d2300\", os.time() + 86400)\n        fibaro.setTimeout(2000, function() \n                                    self:getServiceRateData(QuickApp.addEnergyRates, self, fromDate, toDate) \n                                end)\n    end\n\n    -- Update main Energy rate table when we \"think\" the requests are completed, approx 4 sec.\n    fibaro.setTimeout(4000, function() \n                            self:updateEnergyRateTable(self.serviceRateTable) \n                        end)\nend\n\nfunction QuickApp:updateEnergyRateTable(responseData)\n    local items = self:tableCount(responseData)\n\n    -- Only set energy rate table if we got any response data\n    if items > 0 then\n        self.energyRateTable = responseData\n\n        self.serviceRequestTime = os.date(\"%Y-%m-%d %H:%M\")\n        self:d(\"Energy rate table updated: \" .. self.serviceRequestTime .. \" with \" .. items .. \" items\")\n    end\nend\n\nfunction QuickApp:addEnergyRates(responseData)\n    if responseData == nil then return end\n    if self.serviceRateTable == nil then self.serviceRateTable = {} end\n\n    -- Add response rate data to local service rate table\n    for index, rateData in pairs(responseData) do\n        table.insert(self.serviceRateTable, rateData)\n    end\nend\n\nfunction QuickApp:setEnergyRates()\n    -- Verify that the self.energyRateTable have any data, otherwise exit\n    local count = self:verifyEnergyRateTable(self.energyRateTable)\n    if (count == 0) then return end\n\n    local currentRate = self.mediumRateValue\n    local nextRate = self.mediumRateValue\n    local prevRate = self.mediumRateValue\n    local bCurrent = false\n    local bNext = false\n    local comingRate = 0\n    local comingCount = 0\n    local avgRate = 0\n    \n    -- Get current, next and previous rate time to display (Format: day.hour)\n    local utcNow = os.date(\"!%d.%H\")\n    local utcNext = self:getRateTime(utcNow, \"%d.%H\", 1)\n    local utcPrev= self:getRateTime(utcNow, \"%d.%H\", -1)\n\n    self:d(\"UTC Now Time: [\" .. utcNow .. \"] \" .. self:getRateTime(utcNow, \"%Y-%m-%d %H:%M\") .. \", UTC Next Time: [\" .. utcNext .. \"] \" .. self:getRateTime(utcNext, \"%Y-%m-%d %H:%M\") .. \", UTC Previous Time: [\" .. utcPrev.. \"] \" .. self:getRateTime(utcPrev, \"%Y-%m-%d %H:%M\"))\n\n    -- Get current, next and previous rate values from table\n    for index, rateData in pairs(self.energyRateTable) do\n        -- Calculate rate price as kWh in local currency\n        local ratePrice = string.format(\"%.2f\",(tonumber(rateData.rate)*tonumber(self.exchangeRate)/1000))\n        self:d(\"[\" .. index .. \"] UTC Time: [\" .. rateData.rateTime .. \"] \" .. rateData.rateDate .. \", Rate: \" .. rateData.rate .. \" \" .. \"EUR/mWh\")\n\n        -- Get previous hour energy price rate\n        if (rateData.rateTime == utcPrev) then\n            prevRate = ratePrice\n            self:d(\" => Set previous rate: [\" .. index .. \"] UTC Time: \" .. rateData.rateDate .. \", Rate: \" .. prevRate .. \" (\" .. rateData.rate .. \")\")\n        end\n\n        -- Get current hour energy price rate\n        if (rateData.rateTime == utcNow) then\n            bCurrent = true           \n            currentRate = ratePrice\n            self:d(\" => Set current rate: [\" .. index .. \"] UTC Time: \" .. rateData.rateDate .. \", Rate: \" .. currentRate .. \" (\" .. rateData.rate .. \")\")\n        end\n        \n        -- Get next hour energy price rate\n        if (rateData.rateTime == utcNext) then\n            bNext = true\n            nextRate = ratePrice\n            self:d(\" => Set next rate: [\" .. index .. \"] UTC Time: \" .. rateData.rateDate .. \", Rate: \" .. nextRate .. \" (\" .. rateData.rate .. \")\")\n        end\n\n        -- Sum coming energy rate\n        if bCurrent then \n            comingRate = comingRate + tonumber(ratePrice)\n            comingCount = comingCount + 1\n        end\n    end\n\n    -- Calculate coming energy rate\n    if comingCount > 0 then avgRate = comingRate / comingCount end\n\n    -- Display Energy rate\n    self:displayEnergyRate(count, currentRate, nextRate, prevRate, avgRate, comingCount, (bCurrent and bNext))\nend\n\nfunction QuickApp:verifyEnergyRateTable(energyRateTable)\n    local count = self:tableCount(energyRateTable)\n    \n    -- Reset panels and display if no data in table\n    if count == 0 then\n        self:displayEnergyRate()\n        self:d(\"Warning! Energy data table is empty\")\n    end\n\n    return count\nend"},{"name":"QAChild_NextRank","isMain":false,"isOpen":false,"content":"function QuickApp:validateChildren()\r\n    self:d(\"Validate QuickApp Children\")\r\n    for id,device in pairs(self.childDevices) do\r\n        self:d(tostring(id) .. \" = \" .. device.name)\r\n\r\n        if (device.name == self.child_rank_name) then\r\n            self.next_rank_device_id = id\r\n            self:d(tostring(id) .. \" - child_rank_name: \" .. device.name)\r\n        end\r\n    end\r\n\r\n    if self.next_rank_device_id == nil then\r\n        self:d(\"Create QuickApp Children\")\r\n        self:createRankChild()\r\n    end\r\nend\r\n\r\nfunction QuickApp:createRankChild()\r\n    local child = self:createChildDevice({\r\n        name = self.child_rank_name,\r\n        type = \"com.fibaro.multilevelSensor\",\r\n    }, ENTSOE_Next_Rank)\r\n    self.next_rank_device_id = child.id\r\nend\r\n\r\n\r\nclass 'ENTSOE_Next_Rank' (QuickAppChild)\r\nfunction ENTSOE_Next_Rank:__init(device)\r\n    -- You should not insert code before QuickAppChild.__init.\r\n    QuickAppChild.__init(self, device) -- We must call a constructor from the parent class\r\n    self:updateProperty(\"unit\", \"\")\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setValue(value)\r\n    self:updateProperty(\"value\", value)\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setUnit(unit)\r\n    self:updateProperty(\"unit\", unit)\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setLog(log)\r\n    self:updateProperty(\"log\", log)\r\nend\r\n"},{"name":"functions","isMain":false,"isOpen":false,"content":"function QuickApp:d(msg)\r\n    if self.debugOn then self:debug(msg) end\r\nend\r\n\r\nfunction QuickApp:getRateTime(rateTime, format, addHour)\r\n    if format == nil then format = \"%Y-%m-%d %H:%M\" end\r\n    if addHour == nil then addHour = 0 end\r\n\r\n    -- Input rateTime = \"25.23\" {day.hour}\r\n    local iday, ihour = rateTime:match(\"(%d+).(%d+)\")\r\n    local iyear = tonumber(os.date(\"%Y\"))\r\n    local imonth = tonumber(os.date(\"%m\"))\r\n    local timestamp = os.time({year = iyear, month = imonth, day = iday, hour = ihour, min = 0})\r\n    return os.date(format, timestamp + (addHour * 60 * 60))\r\nend\r\n\r\nfunction QuickApp:getRateDate(dateString, format, addHour, timezoneOffset)\r\n    if format == nil then format = \"%Y-%m-%d %H:%M\" end\r\n    if addHour == nil then addHour = 0 end\r\n    if timezoneOffset == nil then timezoneOffset = 0 end\r\n\r\n    -- Input dateString = \"2022-12-25 23:00\"\r\n    local iyear, imonth, iday, ihour, iminute = dateString:match(\"(%d+)-(%d+)-(%d+) (%d+):(%d+)\")\r\n    local timestamp = os.time({year = iyear, month = imonth, day = iday, hour = ihour, min = iminute}) + timezoneOffset\r\n    return os.date(format, timestamp + (addHour * 60 * 60))\r\nend\r\n\r\nfunction QuickApp:IsTableUpToDate(table, utcTime)\r\n    local utcPrev = self:getRateTime(utcTime, \"%d.%H\", -1)\r\n    local utcNext = self:getRateTime(utcTime, \"%d.%H\", 1)\r\n    if self:existsInTable(table, utcPrev) and self:existsInTable(table, utcNext) then\r\n        self:d(\"Energy rate for ([\" .. utcPrev .. \"] to [\" .. utcNext .. \"]) already exists in table\")\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\nfunction QuickApp:existsInTable(table, match)\r\n    for index, data in pairs(table) do\r\n        if (data[1] == match) then return true end\r\n    end\r\n    return false\r\nend\r\n\r\nfunction QuickApp:tableCount(T)\r\n    if T == nil then return 0 end\r\n    local count = 0\r\n    for _ in pairs(T) do count = count + 1 end\r\n    return count\r\nend\r\n\r\nfunction QuickApp:getXmlDate(xmlString, name, format)\r\n    -- Input dateString = \"2022-12-25T23:00Z\"\r\n    local dateString = self:getXmlElement(xmlString, name)\r\n    local iyear, imonth, iday, ihour, iminute = dateString:match(\"(%d+)-(%d+)-(%d+)T(%d+):(%d+)Z\")\r\n    local timestamp = os.time({year = iyear, month = imonth, day = iday, hour = ihour, min = iminute})\r\n    return os.date(format, timestamp)\r\nend\r\n\r\nfunction QuickApp:getXmlElement(data, name)\r\n    return data:match(\"<\"..name..\">(.-)</\"..name..\">\")\r\nend\r\n\r\nfunction QuickApp:xml2PriceTable(xml)\r\n  local priceTable = {}\r\n  local ni, c, label, xarg, empty\r\n  local i, j = 1, 1\r\n\r\n  while true do\r\n    ni, j, c, label, xarg, empty = string.find(xml, \"<(%/?)([%w:_]+)(.-)(%/?)>\", i)\r\n    if not ni then break end\r\n    local text = string.sub(xml, i, ni-1)\r\n   \r\n    if not string.find(text, \"^%s*$\") and label == \"price\" then\r\n            table.insert(priceTable, text)\r\n    end\r\n\r\n    i = j+1\r\n  end\r\n\r\n  return priceTable\r\nend\r\n\r\nfunction QuickApp:getRank(value)\r\n    local medValue = tonumber(self.mediumRateValue)\r\n    if (value == nil) then value = 0 end\r\n    if (medValue == nil) then medValue = 1 end\r\n    \r\n    -- Calculate percent from medium energy rate\r\n    local percent = (value * 100 / medValue) - 100\r\n    \r\n    local rank = \"MEDIUM\"\r\n    if (percent > 50) then rank = \"HIGH\" end       --  50% higher than medium rate\r\n    if (percent > 100) then rank = \"VeryHIGH\" end  -- 100% higher than medium rate\r\n    if (percent < -100) then rank = \"VeryLOW\" end  -- 100% higher than medium rate\r\n    if (percent < -50) then rank = \"LOW\" end       --  50% higher than medium rate\r\n\r\n    self:d(\"Set the rank level between percentage of \" .. value .. \" and \" .. medValue .. \" = \" .. rank .. \" (\" .. percent .. \"%)\")\r\n\r\n    return rank\r\nend\r\n\r\nfunction QuickApp:getNextDirection(currentValue, nextValue)\r\n    if (currentValue == nil) then currentValue = 0 end\r\n    if (nextValue == nil) then nextValue = 0 end\r\n    if (currentValue > nextValue) then return \"↓\" end\r\n    if (currentValue < nextValue) then return \"↑\" end\r\n    return \"→\"\r\nend"},{"name":"defaults","isMain":false,"isOpen":false,"content":"function QuickApp:createGlobalVariables()\r\n    local medrate_var = {\r\n            name=self.global_var_medium_rate_name,\r\n            isEnum=false,\r\n            readOnly=false,\r\n            value=\"0.2\"  -- 0,2 EUR/kWh\r\n    }\r\n    api.post('/globalVariables/',medrate_var)\r\n\r\n    local level_var = {\r\n            name=self.global_var_level_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=\"HIGH\",\r\n            enumValues={\"VeryLOW\",\"LOW\",\"MEDIUM\",\"HIGH\",\"VeryHIGH\"}\r\n    }\r\n    api.post('/globalVariables/',level_var)\r\n\r\n    level_var.name = self.global_var_next_level_name\r\n    api.post('/globalVariables/',level_var)  \r\nend\r\n\r\nfunction QuickApp:setDefaultVariables()\r\n    if self.token == nil or self.token == \"\" then\r\n        -- Please register at ENTSO-E and create your own account and token!\r\n        -- This Token is only for test purpose and can bee obsolete in the future.\r\n        self.token = \"f442d0b3-450b-46d7-b752-d8d692fdb2c8\"\r\n        fibaro.setVariable(self.default_token_name, self.token)\r\n    end\r\n\r\n    if self.mediumRateValue == nil or self.mediumRateValue == \"\" then\r\n        self.mediumRateValue = \"0.2\" -- 0,2 EUR/kWh\r\n        fibaro.setGlobalVariable(self.global_var_medium_rate_name, self.mediumRateValue)\r\n    end\r\n\r\n    if self.areaCode == nil or self.areaCode == \"\" then\r\n        self.areaName = \"Sweden (SE3)\"\r\n        fibaro.setGlobalVariable(self.global_var_area_name, self.areaName)\r\n    end\r\n    \r\n    self:refreshVariables()\r\nend\r\n\r\nfunction QuickApp:refreshVariables()\r\n    -- Refresh variable values\r\n    self.mediumRateValue = fibaro.getGlobalVariable(self.global_var_medium_rate_name)\r\n    self.areaName = fibaro.getGlobalVariable(self.global_var_area_name)\r\n    self.areaCode = self:getAreaCode(self.areaName)\r\n    self:updateProperty(\"unit\", self.currency .. \"/kWh\")\r\n\r\n    -- Get Fibaro settings\r\n    local settings = api.get(\"/settings/info\")\r\n    self.currency = settings.currency\r\n    self.timezoneOffset = tonumber(settings.timezoneOffset)\r\nend"},{"name":"display","isMain":false,"isOpen":false,"content":"function QuickApp:resetDisplayPanels(text)\r\n    self:updateView(\"labelInfo\", \"text\", text)\r\nend\r\n\r\nfunction QuickApp:displayEnergyRate(count, currentRate, nextRate, prevRate, avgComingRate, avgCount, realData)\r\n    if count == nil then count = 0 end\r\n    if currentRate == nil then currentRate = self.mediumRateValue end\r\n    if nextRate == nil then nextRate = currentRate end\r\n    if prevRate == nil then prevRate = currentRate end\r\n    if avgComingRate == nil then avgComingRate = currentRate end\r\n    if avgCount == nil then avgCount = 0 end\r\n    if realData == nil then realData = false end\r\n\r\n    self:updateView(\"updateButton\", \"text\", \"Updating, please wait...\")\r\n    \r\n    -- Calculate values\r\n    local rank = self:getRank(currentRate)\r\n    local nextRank = self:getRank(tonumber(nextRate))\r\n    local nextDir = self:getNextDirection(currentRate, nextRate)\r\n    local prevDir = self:getNextDirection(prevRate, currentRate)\r\n    local rateDiff = string.format(\"%.2f\", tonumber(nextRate - currentRate))\r\n    local prevDiff = string.format(\"%.2f\", tonumber(currentRate - prevRate))\r\n\r\n    local avgRate = 0\r\n    local lastRqt = \"Loading Energy rates...\"\r\n    local lastUpd = \"Refreshing...\"\r\n    local areaName = self.areaName\r\n    local actual = \" \"\r\n\r\n    if not self.serviceSuccess then\r\n        lastRqt = \"n/a\"\r\n        lastUpd = \"n/a\"\r\n        areaName = self.areaName .. \"\\n** Missing Energy rates for selected Area **\"\r\n        self:updateView(\"updateButton\", \"text\", \"Refresh Rates\")\r\n    end\r\n\r\n    if count > 0 then \r\n        avgRate = string.format(\"%.2f\", avgComingRate)\r\n        lastRqt = self.serviceRequestTime\r\n    end\r\n\r\n    if not realData then \r\n        self:d(\"Warning! Current Energy rate time not exists in current energy table!\")\r\n        actual = \"* \" -- Show that rates are not accurate\r\n    end\r\n\r\n    -- Only update variables and tariff if we got \"real\" rate data\r\n    if count > 0 and realData then \r\n        self:updateProperty('value', tonumber(currentRate))\r\n        self:updateProperty('log', rank)\r\n        fibaro.setGlobalVariable(self.global_var_level_name, rank)        \r\n        fibaro.setGlobalVariable(self.global_var_next_level_name, nextRank)\r\n        fibaro.call(self.next_rank_device_id, 'setLog', nextRank)\r\n        fibaro.call(self.next_rank_device_id, 'setUnit', \" \" .. nextDir)\r\n        fibaro.call(self.next_rank_device_id, 'setValue', rateDiff)\r\n\r\n        -- Update Fibaro Energy Tariff panel\r\n        self:updateTariffPanel(currentRate, self.energyRateTable, self.exchangeRate, self.timezoneOffset)\r\n\r\n        self:updateView(\"updateButton\", \"text\", \"Refresh Rates\")\r\n        lastUpd = os.date(\"%Y-%m-%d %H:%M\")\r\n\r\n        self:d(\"Display panels updated: \" .. os.date(\"%H:%M:%S\"))\r\n    end\r\n\r\n    -- Update ENTSO-e Info panel\r\n    self:updateView(\"labelInfo\", \"text\", \"Current rate: \" .. currentRate .. actual .. self.currency .. \"/kWh (\" .. prevDiff .. prevDir .. \") \" .. rank .. \"\\nNext rate: \" .. nextRate .. actual .. self.currency .. \"/kWh (\" .. rateDiff .. nextDir .. \") \" .. nextRank .. \"\\nAverage rate coming \" .. avgCount .. \" hours: \" .. avgRate .. actual .. self.currency .. \"/kWh\\n\\nEnergy rate update: \" .. lastRqt .. \"\\nVariable update: \" .. lastUpd .. \"\\nArea: \" .. areaName .. \"\\nAreaCode: \" .. self.areaCode .. \"\\n\\nExchange rate: 1 EUR = \" .. self.exchangeRate .. \" \" .. self.currency)\r\n\r\n    self:d(\"Current (\" .. rank .. \") Rate: \" .. currentRate .. actual .. self.currency .. \"/kWh\" .. \", Next (\" .. nextRank .. \") Rate: \" .. nextRate .. actual .. self.currency .. \"/kWh\" .. \" (\" .. rateDiff .. nextDir .. \")\")\r\nend\r\n\r\nfunction QuickApp:updateTariffPanel(currentRate, energyRateTable, exchangeRate, timezoneOffset)\r\n    -- Get current Fibaro Energy Tariff data\r\n    local tariffData = api.get(\"/energy/billing/tariff\")\r\n    local tariff = {}\r\n    local addTariffs = {}\r\n   \r\n    -- Create Additional Tariff table in local currency and timezone\r\n    for index, rateData in pairs(energyRateTable) do\r\n        tariff = {\r\n            name = self:getRateDate(rateData.rateDate, \"%Y-%m-%d %H:%M\", 0, timezoneOffset),\r\n            rate = self:getTariffRate(rateData.rate, exchangeRate),\r\n            startTime = self:getRateDate(rateData.rateDate, \"%H:%M\", 0, timezoneOffset),\r\n            endTime = self:getRateDate(rateData.rateDate, \"%H:%M\", 1, timezoneOffset),\r\n            days = {string.lower(self:getRateDate(rateData.rateDate, \"%A\", 0, timezoneOffset))}\r\n        }\r\n        table.insert(addTariffs, tariff)\r\n    end\r\n\r\n    -- Update current tariff with new Tariff data\r\n    local response, code = api.put(\"/energy/billing/tariff\", {\r\n        returnRate = tariffData.returnRate,\r\n        additionalTariffs = addTariffs,\r\n        name = tariffData.name,\r\n        rate = tonumber(currentRate)\r\n    })\r\n\r\n    self:d(\"Update Tariff response \" .. tostring(code) .. \" - \\\"\" .. tariffData.name .. \"\\\" Rate: \" .. tariffData.rate .. \" => \" .. currentRate .. \" (TimezoneOffset: \" .. timezoneOffset .. \")\")\r\nend\r\n\r\nfunction QuickApp:getTariffRate(mainRate, exchangeRate)\r\n    local rate = tonumber(string.format(\"%.2f\",(tonumber(mainRate)*tonumber(exchangeRate)/1000)))\r\n    if rate <= 0 then rate = 0.0001 end -- Fibaro can't accept 0 as tariff rate :(\r\n    return rate    \r\nend"},{"name":"exchangeRate","isMain":false,"isOpen":false,"content":"-- Exchange rates API is a simple and lightweight free service for current and historical foreign exchange rates & crypto exchange rates.\r\n-- Reliable and up-to-date EU VAT rates, sourced directly from the European Commission's databases.\r\n-- If you like it, donate a cappuccino https://exchangerate.host/#/donate ;)\r\n\r\n-- Service home site: https://exchangerate.host\r\n\r\nfunction QuickApp:setExchangeRate(responseData)\r\n    if responseData == nil then\r\n        self:debug(\"Exchange Rate: Error when request rate!\")\r\n    end\r\n\r\n    for curr, value in pairs(responseData.rates) do\r\n        self.exchangeRate = tonumber(value)\r\n        self:d(\"Exchange Rate: 1 EUR = \" .. value .. \" \" .. curr)\r\n    end\r\nend\r\n\r\nfunction QuickApp:getServiceExchangeData(callback, instance)\r\n    -- Request exchangerate.host with base currency \"EUR\" that always is ENTSO-e response currency\r\n    local url = self.exchangerate_baseURL .. \"latest?base=EUR&symbols=\" .. self.currency .. \"&amount=1\"\r\n    self.httpClient:request(url, {\r\n        options = {\r\n            method = \"GET\",\r\n            headers = {[\"Accept\"] = \"application/json\"}\r\n        },\r\n        success = function(response)\r\n            local success, data = pcall(function()\r\n                                            return json.decode(response.data)\r\n                                        end)\r\n\r\n            if success then\r\n                pcall(callback, instance, data)\r\n            else\r\n                self:debug(\"Broken json response from Url: \" .. url)\r\n                return nil\r\n            end\r\n        end,\r\n        error = function(message)\r\n            self:debug(\"Error:\", message)\r\n            return nil\r\n        end\r\n    })\r\nend\r\n"},{"name":"entsoe_GetDayPrice","isMain":false,"isOpen":false,"content":"-- https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_generation_domain\r\n-- 4.2.10. Day Ahead Rates [12.1.D]\r\n\r\nfunction QuickApp:getServiceRateData(callback, instance, fromdate, todate)\r\n    self:d(\"Request ENTSO-e for period UTC: \" .. fromdate .. \" -- \" .. todate .. \" (AreaCode: \" .. self.areaCode .. \")\")\r\n\r\n    local ratePrice = {}\r\n    local ratePrices = {}\r\n    local rateTable = {}\r\n    local url = self.entsoe_baseURL .. \"?documentType=A44&in_Domain=\" .. self.areaCode .. \"&out_Domain=\" .. self.areaCode .. \"&periodStart=\" .. fromdate .. \"&periodEnd=\" .. todate .. \"&securityToken=\" .. self.token\r\n\r\n    self.httpClient:request(url, {\r\n        options = {\r\n            method = \"GET\",\r\n            headers = {\r\n                [\"SECURITY_TOKEN\"] = self.token,\r\n                [\"Accept\"] = \"text/xml\"\r\n            }\r\n        },\r\n        success = function(response)\r\n            -- Create Rate table from XML response\r\n            local periodXml = self:getXmlElement(response.data, \"Period\")\r\n            local success, data = pcall(function()\r\n                                            return self:xml2PriceTable(periodXml)\r\n                                        end)\r\n\r\n            if success then\r\n                if data == nil then \r\n                    self:debug(\"ERROR: Response is empty\")\r\n                    return nil\r\n                end\r\n\r\n                -- Get UTC start and end date from response XML\r\n                local startDate = self:getXmlDate(periodXml, \"start\", \"%Y-%m-%d %H:%M\")\r\n                local endDate = self:getXmlDate(periodXml, \"end\", \"%Y-%m-%d %H:%M\")\r\n\r\n                -- Create (UTC) date and rate table\r\n                for index, rate in pairs(data) do\r\n                    ratePrice = {\r\n                        rateDate = self:getRateDate(startDate, \"%Y-%m-%d %H:%M\", index - 1),\r\n                        rateTime = self:getRateDate(startDate, \"%d.%H\", index - 1),\r\n                        rate = rate\r\n                    }\r\n                    table.insert(ratePrices, ratePrice)\r\n                end\r\n\r\n                self:d(\"=> Response: Start UTC = \" .. startDate .. \", End UTC = \" .. endDate .. \", \" .. self:tableCount(ratePrices) .. \" rates\")\r\n    \r\n                pcall(callback, instance, ratePrices)\r\n            else\r\n                self.serviceSuccess = false\r\n                self:debug(\"Broken xml response from Url: \" .. url)\r\n                return nil\r\n            end\r\n        end,\r\n        error = function(message)\r\n            self:debug(\"Error:\", message)\r\n            return nil\r\n        end\r\n    })\r\nend\r\n"},{"name":"entsoe_AreaCodes","isMain":false,"isOpen":false,"content":"-- See \"BZN\" Area codes at: https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_areas\r\n\r\nfunction QuickApp:createAreaVariables()\r\n    local level_var = {\r\n            name=self.global_var_area_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=self.default_area_name,\r\n            enumValues={\"Albania (AL)\",\"Austria (AT)\",\"Belgium (BE)\",\"Bosnia and Herz. (BA)\",\"Bulgaria (BG)\",\"Croatia (HR)\",\"Czech Republic (CZ)\",\"Denmark (DK1)\",\"Denmark (DK2)\",\"Estonia (EE)\",\"Finland (FI)\",\"France (FR)\",\"Germany (DE-LU)\",\"Greece (GR)\",\"Hungary (HU)\",\"Ireland (SEM)\",\"Italy (Centre-North)\",\"Italy (South)\",\"Italy (Centre-South)\",\"Italy (North)\",\"Latvia (LV)\",\"Lithuania (LT)\",\"Netherlands (NL)\",\"North Macedonia (MK)\",\"Norway (NO1)\",\"Norway (NO2)\",\"Norway (NO2NSL)\",\"Norway (NO3)\",\"Norway (NO4)\",\"Norway (NO5)\",\"Poland (PL)\",\"Portugal (PT)\",\"Romania (RO)\",\"Serbia (RS)\",\"Slovakia (SK)\",\"Slovenia (SI)\",\"Spain (ES)\",\"Sweden (SE1)\",\"Sweden (SE2)\",\"Sweden (SE3)\",\"Sweden (SE4)\",\"Switzerland (CH)\",\"Ukraine (UA-BEI)\",\"United Kingdom (GB)\"}\r\n    }\r\n    api.post('/globalVariables/',level_var)    \r\nend\r\n\r\nfunction QuickApp:getAreaCode(areaName)\r\n    -- Set default Area code if \"areaName\" is missing.\r\n    if areaName == nil or areaName == \"\" then areaName = self.default_area_name end\r\n    \r\n    if (areaName == \"Albania (AL)\") then return \"10YAL-KESH-----5\" end\r\n    if (areaName == \"Austria (AT)\") then return \"10YAT-APG------L\" end\r\n    if (areaName == \"Belgium (BE)\") then return \"10YBE----------2\" end\r\n    if (areaName == \"Bosnia and Herz. (BA)\") then return \"10YBA-JPCC-----D\" end\r\n    if (areaName == \"Bulgaria (BG)\") then return \"10YCA-BULGARIA-R\" end\r\n    if (areaName == \"Croatia (HR)\") then return \"10YHR-HEP------M\" end\r\n    if (areaName == \"Czech Republic (CZ)\") then return \"10YCZ-CEPS-----N\" end\r\n    if (areaName == \"Denmark (DK1)\") then return \"10YDK-1--------W\" end\r\n    if (areaName == \"Denmark (DK2)\") then return \"10YDK-2--------M\" end\r\n    if (areaName == \"Estonia (EE)\") then return \"10Y1001A1001A39I\" end\r\n    if (areaName == \"Finland (FI)\") then return \"10YFI-1--------U\" end\r\n    if (areaName == \"France (FR)\") then return \"10YFR-RTE------C\" end\r\n    if (areaName == \"Germany (DE-LU)\") then return \"10Y1001A1001A82H\" end\r\n    if (areaName == \"Greece (GR)\") then return \"10YGR-HTSO-----Y\" end\r\n    if (areaName == \"Hungary (HU)\") then return \"10YHU-MAVIR----U\" end\r\n    if (areaName == \"Ireland (SEM)\") then return \"10Y1001A1001A59C\" end\r\n    if (areaName == \"Italy (Centre-North)\") then return \"10Y1001A1001A70O\" end\r\n    if (areaName == \"Italy (South)\") then return \"10Y1001A1001A788\" end\r\n    if (areaName == \"Italy (Centre-South)\") then return \"10Y1001A1001A71M\" end\r\n    if (areaName == \"Italy (North)\") then return \"10Y1001A1001A73I\" end\r\n    if (areaName == \"Latvia (LV)\") then return \"10YLV-1001A00074\" end\r\n    if (areaName == \"Lithuania (LT)\") then return \"10YLT-1001A0008Q\" end\r\n    if (areaName == \"Netherlands (NL)\") then return \"10YNL----------L\" end\r\n    if (areaName == \"North Macedonia (MK)\") then return \"10YMK-MEPSO----8\" end\r\n    if (areaName == \"Norway (NO1)\") then return \"10YNO-1--------2\" end\r\n    if (areaName == \"Norway (NO2)\") then return \"10YNO-2--------T\" end\r\n    if (areaName == \"Norway (NO2NSL)\") then return \"50Y0JVU59B4JWQCU\" end\r\n    if (areaName == \"Norway (NO3)\") then return \"10YNO-3--------J\" end\r\n    if (areaName == \"Norway (NO4)\") then return \"10YNO-4--------9\" end\r\n    if (areaName == \"Norway (NO5)\") then return \"10Y1001A1001A48H\" end\r\n    if (areaName == \"Poland (PL)\") then return \"10YPL-AREA-----S\" end\r\n    if (areaName == \"Portugal (PT)\") then return \"10YPT-REN------W\" end\r\n    if (areaName == \"Romania (RO)\") then return \"10YRO-TEL------P\" end\r\n    if (areaName == \"Serbia (RS)\") then return \"10YCS-SERBIATSOV\" end\r\n    if (areaName == \"Slovakia (SK)\") then return \"10YSK-SEPS-----K\" end\r\n    if (areaName == \"Slovenia (SI)\") then return \"10YSI-ELES-----O\" end\r\n    if (areaName == \"Spain (ES)\") then return \"10YES-REE------0\" end\r\n    if (areaName == \"Sweden (SE1)\") then return \"10Y1001A1001A44P\" end\r\n    if (areaName == \"Sweden (SE2)\") then return \"10Y1001A1001A45N\" end\r\n    if (areaName == \"Sweden (SE3)\") then return \"10Y1001A1001A46L\" end\r\n    if (areaName == \"Sweden (SE4)\") then return \"10Y1001A1001A47J\" end\r\n    if (areaName == \"Switzerland (CH)\") then return \"10YCH-SWISSGRIDZ\" end\r\n    if (areaName == \"Ukraine (UA-BEI)\") then return \"10YUA-WEPS-----0\" end\r\n    if (areaName == \"United Kingdom (GB)\") then return \"10YGB----------A\" end\r\n\r\n    return \"\" -- No match\r\nend"}]}